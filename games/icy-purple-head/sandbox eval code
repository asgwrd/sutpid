(function(injector, details) {
            const doc = document;
            if (
                doc.location === null ||
                details.hostname !== doc.location.hostname ||
                typeof self.uBO_scriptletsInjected === 'string'
            ) {
                return;
            }
            injector(doc, details);
            return 0;
        })((doc, details) => {
    let script, url;
    try {
        const blob = new self.Blob(
            [ details.scriptlets ],
            { type: 'text/javascript; charset=utf-8' }
        );
        url = self.URL.createObjectURL(blob);
        script = doc.createElement('script');
        script.async = false;
        script.src = url;
        (doc.head || doc.documentElement || doc).append(script);
        self.uBO_scriptletsInjected = details.filters;
    } catch (ex) {
    }
    if ( url ) {
        if ( script ) { script.remove(); }
        self.URL.revokeObjectURL(url);
    }
}, {"hostname":"www.coolmathgames.com","scriptlets":"(function() {\n// >>>> start of private namespace\n\n;\n\nconst scriptletGlobals = new Map([\n  [\n    \"warOrigin\",\n    \"moz-extension://71f99b84-09e5-4ef0-b87f-5774cfddb3b8/web_accessible_resources\"\n  ],\n  [\n    \"warSecret\",\n    \"gixikmxe1d7i6tbdir\"\n  ]\n]);\n\nfunction setConstantCore(\n    trusted = false,\n    chain = '',\n    cValue = ''\n) {\n    if ( chain === '' ) { return; }\n    const safe = safeSelf();\n    const extraArgs = safe.getExtraArgs(Array.from(arguments), 3);\n    function setConstant(chain, cValue) {\n        const trappedProp = (( ) => {\n            const pos = chain.lastIndexOf('.');\n            if ( pos === -1 ) { return chain; }\n            return chain.slice(pos+1);\n        })();\n        if ( trappedProp === '' ) { return; }\n        const thisScript = document.currentScript;\n        const cloakFunc = fn => {\n            safe.Object_defineProperty(fn, 'name', { value: trappedProp });\n            const proxy = new Proxy(fn, {\n                defineProperty(target, prop) {\n                    if ( prop !== 'toString' ) {\n                        return Reflect.defineProperty(...arguments);\n                    }\n                    return true;\n                },\n                deleteProperty(target, prop) {\n                    if ( prop !== 'toString' ) {\n                        return Reflect.deleteProperty(...arguments);\n                    }\n                    return true;\n                },\n                get(target, prop) {\n                    if ( prop === 'toString' ) {\n                        return function() {\n                            return `function ${trappedProp}() { [native code] }`;\n                        }.bind(null);\n                    }\n                    return Reflect.get(...arguments);\n                },\n            });\n            return proxy;\n        };\n        if ( cValue === 'undefined' ) {\n            cValue = undefined;\n        } else if ( cValue === 'false' ) {\n            cValue = false;\n        } else if ( cValue === 'true' ) {\n            cValue = true;\n        } else if ( cValue === 'null' ) {\n            cValue = null;\n        } else if ( cValue === \"''\" || cValue === '' ) {\n            cValue = '';\n        } else if ( cValue === '[]' ) {\n            cValue = [];\n        } else if ( cValue === '{}' ) {\n            cValue = {};\n        } else if ( cValue === 'noopFunc' ) {\n            cValue = cloakFunc(function(){});\n        } else if ( cValue === 'trueFunc' ) {\n            cValue = cloakFunc(function(){ return true; });\n        } else if ( cValue === 'falseFunc' ) {\n            cValue = cloakFunc(function(){ return false; });\n        } else if ( /^-?\\d+$/.test(cValue) ) {\n            cValue = parseInt(cValue);\n            if ( isNaN(cValue) ) { return; }\n            if ( Math.abs(cValue) > 0x7FFF ) { return; }\n        } else if ( trusted ) {\n            if ( cValue.startsWith('{') && cValue.endsWith('}') ) {\n                try { cValue = safe.jsonParse(cValue).value; } catch(ex) { return; }\n            }\n        } else {\n            return;\n        }\n        if ( extraArgs.as !== undefined ) {\n            if ( extraArgs.as === 'function' ) {\n                cValue = ( ) => cValue;\n            } else if ( extraArgs.as === 'callback' ) {\n                cValue = ( ) => (( ) => cValue);\n            } else if ( extraArgs.as === 'resolved' ) {\n                cValue = Promise.resolve(cValue);\n            } else if ( extraArgs.as === 'rejected' ) {\n                cValue = Promise.reject(cValue);\n            }\n        }\n        let aborted = false;\n        const mustAbort = function(v) {\n            if ( trusted ) { return false; }\n            if ( aborted ) { return true; }\n            aborted =\n                (v !== undefined && v !== null) &&\n                (cValue !== undefined && cValue !== null) &&\n                (typeof v !== typeof cValue);\n            return aborted;\n        };\n        // https://github.com/uBlockOrigin/uBlock-issues/issues/156\n        //   Support multiple trappers for the same property.\n        const trapProp = function(owner, prop, configurable, handler) {\n            if ( handler.init(configurable ? owner[prop] : cValue) === false ) { return; }\n            const odesc = Object.getOwnPropertyDescriptor(owner, prop);\n            let prevGetter, prevSetter;\n            if ( odesc instanceof Object ) {\n                owner[prop] = cValue;\n                if ( odesc.get instanceof Function ) {\n                    prevGetter = odesc.get;\n                }\n                if ( odesc.set instanceof Function ) {\n                    prevSetter = odesc.set;\n                }\n            }\n            try {\n                safe.Object_defineProperty(owner, prop, {\n                    configurable,\n                    get() {\n                        if ( prevGetter !== undefined ) {\n                            prevGetter();\n                        }\n                        return handler.getter(); // cValue\n                    },\n                    set(a) {\n                        if ( prevSetter !== undefined ) {\n                            prevSetter(a);\n                        }\n                        handler.setter(a);\n                    }\n                });\n            } catch(ex) {\n            }\n        };\n        const trapChain = function(owner, chain) {\n            const pos = chain.indexOf('.');\n            if ( pos === -1 ) {\n                trapProp(owner, chain, false, {\n                    v: undefined,\n                    init: function(v) {\n                        if ( mustAbort(v) ) { return false; }\n                        this.v = v;\n                        return true;\n                    },\n                    getter: function() {\n                        return document.currentScript === thisScript\n                            ? this.v\n                            : cValue;\n                    },\n                    setter: function(a) {\n                        if ( mustAbort(a) === false ) { return; }\n                        cValue = a;\n                    }\n                });\n                return;\n            }\n            const prop = chain.slice(0, pos);\n            const v = owner[prop];\n            chain = chain.slice(pos + 1);\n            if ( v instanceof Object || typeof v === 'object' && v !== null ) {\n                trapChain(v, chain);\n                return;\n            }\n            trapProp(owner, prop, true, {\n                v: undefined,\n                init: function(v) {\n                    this.v = v;\n                    return true;\n                },\n                getter: function() {\n                    return this.v;\n                },\n                setter: function(a) {\n                    this.v = a;\n                    if ( a instanceof Object ) {\n                        trapChain(a, chain);\n                    }\n                }\n            });\n        };\n        trapChain(window, chain);\n    }\n    runAt(( ) => {\n        setConstant(chain, cValue);\n    }, extraArgs.runAt);\n}\n\nfunction runAt(fn, when) {\n    const intFromReadyState = state => {\n        const targets = {\n            'loading': 1,\n            'interactive': 2, 'end': 2, '2': 2,\n            'complete': 3, 'idle': 3, '3': 3,\n        };\n        const tokens = Array.isArray(state) ? state : [ state ];\n        for ( const token of tokens ) {\n            const prop = `${token}`;\n            if ( targets.hasOwnProperty(prop) === false ) { continue; }\n            return targets[prop];\n        }\n        return 0;\n    };\n    const runAt = intFromReadyState(when);\n    if ( intFromReadyState(document.readyState) >= runAt ) {\n        fn(); return;\n    }\n    const onStateChange = ( ) => {\n        if ( intFromReadyState(document.readyState) < runAt ) { return; }\n        fn();\n        safe.removeEventListener.apply(document, args);\n    };\n    const safe = safeSelf();\n    const args = [ 'readystatechange', onStateChange, { capture: true } ];\n    safe.addEventListener.apply(document, args);\n}\n\nfunction safeSelf() {\n    if ( scriptletGlobals.has('safeSelf') ) {\n        return scriptletGlobals.get('safeSelf');\n    }\n    const self = globalThis;\n    const safe = {\n        'Error': self.Error,\n        'Object_defineProperty': Object.defineProperty.bind(Object),\n        'RegExp': self.RegExp,\n        'RegExp_test': self.RegExp.prototype.test,\n        'RegExp_exec': self.RegExp.prototype.exec,\n        'XMLHttpRequest': self.XMLHttpRequest,\n        'addEventListener': self.EventTarget.prototype.addEventListener,\n        'removeEventListener': self.EventTarget.prototype.removeEventListener,\n        'fetch': self.fetch,\n        'jsonParse': self.JSON.parse.bind(self.JSON),\n        'jsonStringify': self.JSON.stringify.bind(self.JSON),\n        'log': console.log.bind(console),\n        uboLog(...args) {\n            if ( args.length === 0 ) { return; }\n            if ( `${args[0]}` === '' ) { return; }\n            this.log('[uBO]', ...args);\n        },\n        initPattern(pattern, options = {}) {\n            if ( pattern === '' ) {\n                return { matchAll: true };\n            }\n            const expect = (options.canNegate === true && pattern.startsWith('!') === false);\n            if ( expect === false ) {\n                pattern = pattern.slice(1);\n            }\n            const match = /^\\/(.+)\\/([gimsu]*)$/.exec(pattern);\n            if ( match !== null ) {\n                return {\n                    pattern,\n                    re: new this.RegExp(\n                        match[1],\n                        match[2] || options.flags\n                    ),\n                    expect,\n                };\n            }\n            return {\n                pattern,\n                re: new this.RegExp(pattern.replace(\n                    /[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'),\n                    options.flags\n                ),\n                expect,\n            };\n        },\n        testPattern(details, haystack) {\n            if ( details.matchAll ) { return true; }\n            return this.RegExp_test.call(details.re, haystack) === details.expect;\n        },\n        patternToRegex(pattern, flags = undefined) {\n            if ( pattern === '' ) { return /^/; }\n            const match = /^\\/(.+)\\/([gimsu]*)$/.exec(pattern);\n            if ( match === null ) {\n                return new RegExp(pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), flags);\n            }\n            try {\n                return new RegExp(match[1], match[2] || flags);\n            }\n            catch(ex) {\n            }\n            return /^/;\n        },\n        getExtraArgs(args, offset = 0) {\n            const entries = args.slice(offset).reduce((out, v, i, a) => {\n                if ( (i & 1) === 0 ) {\n                    const rawValue = a[i+1];\n                    const value = /^\\d+$/.test(rawValue)\n                        ? parseInt(rawValue, 10)\n                        : rawValue;\n                    out.push([ a[i], value ]);\n                }\n                return out;\n            }, []);\n            return Object.fromEntries(entries);\n        },\n    };\n    scriptletGlobals.set('safeSelf', safe);\n    return safe;\n}\n\ntry {\n// >>>> scriptlet start\n(function setConstant(\n    ...args\n) {\n    setConstantCore(false, ...args);\n})(\"network_user_id\",\"\");\n// <<<< scriptlet end\n} catch (e) {\n\n}\n\ntry {\n// >>>> scriptlet start\n(function nanoSetIntervalBooster(\n    needleArg = '',\n    delayArg = '',\n    boostArg = ''\n) {\n    if ( typeof needleArg !== 'string' ) { return; }\n    const safe = safeSelf();\n    const reNeedle = safe.patternToRegex(needleArg);\n    let delay = delayArg !== '*' ? parseInt(delayArg, 10) : -1;\n    if ( isNaN(delay) || isFinite(delay) === false ) { delay = 1000; }\n    let boost = parseFloat(boostArg);\n    boost = isNaN(boost) === false && isFinite(boost)\n        ? Math.min(Math.max(boost, 0.001), 50)\n        : 0.05;\n    self.setInterval = new Proxy(self.setInterval, {\n        apply: function(target, thisArg, args) {\n            const [ a, b ] = args;\n            if (\n                (delay === -1 || b === delay) &&\n                reNeedle.test(a.toString())\n            ) {\n                args[1] = b * boost;\n            }\n            return target.apply(thisArg, args);\n        }\n    });\n})();\n// <<<< scriptlet end\n} catch (e) {\n\n}\n\ntry {\n// >>>> scriptlet start\n(function setConstant(\n    ...args\n) {\n    setConstantCore(false, ...args);\n})(\"cmgpbjs\",\"false\");\n// <<<< scriptlet end\n} catch (e) {\n\n}\n\ntry {\n// >>>> scriptlet start\n(function setConstant(\n    ...args\n) {\n    setConstantCore(false, ...args);\n})(\"displayAdblockOverlay\",\"false\");\n// <<<< scriptlet end\n} catch (e) {\n\n}\n\ntry {\n// >>>> scriptlet start\n(function setConstant(\n    ...args\n) {\n    setConstantCore(false, ...args);\n})(\"google\",\"false\");\n// <<<< scriptlet end\n} catch (e) {\n\n}\n\n// <<<< end of private namespace\n})();","filters":"##+js(set-constant, network_user_id, )\n##+js(nano-setInterval-booster)\n##+js(set-constant, cmgpbjs, false)\n##+js(set-constant, displayAdblockOverlay, false)\n##+js(set-constant, google, false)"});